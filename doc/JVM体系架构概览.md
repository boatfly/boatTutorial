# JVM体系架构概览
img/jvm.png
## 类装载器
- 负责加载class文件，class文件在文件开头有特定的文件标示(`cafebabe`)，将class文件字节码内容加载到内存中。
- 只负责加载，是否运行有Executor Engine来决定。
- class->Class

粗说3个，细说4个。img/jvm-tpye.png
sun.misc.Launcher的入口程序。
- 启动类加载器
- 扩展类加载器
- 系统加载器
- 用户自定义加载器

### 双亲委派沙箱安全机制
- 双亲委派
  - 类加载器加载顺序从上到下。当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一层次类加载器都是如此，因此所有的加载请求都应该委派给启动类加载器中，只有当父类加载器无法完成这个请求的时候（在他的加载路径下没有找到所需加载的class），子类加载器才回尝试自己去加载。
- 沙箱安全机制
  - 正式由于双亲委派的机制才能保证自定义的类不会污染java源代码。

## 本地接口 Native Interface
融合不同的编程语言为Java所用。在内存中专门开辟一块区域来处理标记为natived的代码。类装载之后放入`本地方法栈`
```
new Thread().start() -> start0() //进程、线程是系统级的，和语言无关，其创建需要调用系统底层方法。
private native void start0(); //只有声明，没有实现。
```

## PC寄存器（程序计数器）
cpu有一小块叫寄存器。就是一个指针，我这个指令运行完之后下一个要执行的指令是谁。
- 每一个线程都一个程序计数器；线程私有；
- 就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址），由执行引擎读取下一条指令；
- native方法，计数器是空的；

## 方法区
- 供个线程共享的运行时内存区域，所有线程共享。
- 它存储了每一个类的j`结构信息`。
- 存在垃圾回收。永久代（PermGen space）、元空间（Metaspace）
- 实例变量存在堆内存中，与方法区无关。

## 栈 stack
也叫栈内存，主管java程序的运行，是在线程创建时创建。它的生命周期紧随线程的生命期，线程接触栈内存也就释放。对栈来说，不存在垃圾回收问题。
栈管运行，堆管存储。
- 队列 （FIFO），栈：后进先出，先进后出。
- 栈存储什么？方法==栈帧
  - 本地变量：输入参数和输出参数以及方法内的变量；
  - 栈操作：记录出栈、入栈的操作；
  - 栈帧数据：包括类文件和方法等；
  - 大小约1M左右 java.lang.StackOverFlowError (SOF) 如：方法死循环
### 栈运行原理
后进先出，先进后出。

## 堆 heap
一个jvm实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把l类、方法、常变量放到堆内存中，保存所有引用类型的真是信息，以方便执行器执行。

- 新生代
  - 伊甸园区 Eden 
    - gc：YGC:轻量级GC,Eden区基本全部清空，未清空的，则移到幸存者0区
  - 幸存者0区 Survivor 0 space （from）
  - 幸存者1区 Survivor 1 space （to）
    - from和to，他们的位置和名分，不是固定的，每次GC后交换，GC之后有交换，谁空谁是to
- 老年代
  - 养老区满了，开启full gc：重量级，尽量避免
  - full gc，依然发现老年带没有多余空间，出发oom，堆内存溢出。
  - OOM 
    - Jvm 堆内存设置不够 -Xms -Xmx
    - 代码中创建了大量对象，并且长时间不能被gc回收，存在被引用。
- 元空间 （永久代java7之前）
  - 方法区的一个落地实现。
  - java8之后，元空间并不在虚拟机中而使用本机物理内存。

### Minor GC 的过程（复制-清空-交换）
- Eden\From复制到to，年龄+1
- 清空Eden，from
- to 和 from 交换
  - 交换15次（-XX:maxTenuringThrehold），如果还活着，则移至老年代
  
### 堆参数调优
- Xms
  - 设置初始分配大小，默认为物理内存的1/64
  - -Xms1024m
- Xmx
  - 最大分配内存，默认为w物理内存的1/4
  - -Xmx1024m
- XX:+PrintGCDetails
  - 输出详细的GC处理日志
```$xslt
Heap
 PSYoungGen      total 305664K, used 15729K [0x00000007aab00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 262144K, 6% used [0x00000007aab00000,0x00000007aba5c420,0x00000007bab00000)
  from space 43520K, 0% used [0x00000007bd580000,0x00000007bd580000,0x00000007c0000000)
  to   space 43520K, 0% used [0x00000007bab00000,0x00000007bab00000,0x00000007bd580000)
 ParOldGen       total 699392K, used 0K [0x0000000780000000, 0x00000007aab00000, 0x00000007aab00000)
  object space 699392K, 0% used [0x0000000780000000,0x0000000780000000,0x00000007aab00000)
 Metaspace       used 2754K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 294K, capacity 386K, committed 512K, reserved 1048576K
```

## GC
- 分代搜集算法
  - 次数上频繁搜集YOUNG区
  - 次数上较少搜集OLD区
  - 基本不动元空间
- 4大算法
  - 引用计数法
  - 复制算法 Copying 
    - eden+from->to
    - 用在`新生代`
    - 原理
      - 从根集合（GC Root）开始，通过Tracing从From中找到存活对象，拷贝到to中；
      - From，To交换身份，下次内存分配从to开始
      - 优点：不会产生内存碎片；
      - 缺点：耗空间；
  - 标记清楚 Mark-Sweep
   - 用在`老年代`
   - 原理
     - 分成标记和清楚两个阶段：先标记出要回收的对象，然后统一回收这些对象。
     - 缺点：两次扫描，耗时严重；会产生内存碎片；
  - 标记压缩 Mark-Compact
   - 用在`老年代`
   - 原理
     - 标记-清除
     - 压缩
  
  
G1垃圾回收 jdk9+

## JMM java内存模型
一组内存规范。
线程->工作内存->主内存
volatile是jvm提供的轻量级的同步机制
JMM三个特性：
- 可见性
- 原子性
- 有序性

